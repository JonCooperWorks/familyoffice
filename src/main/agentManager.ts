import { AgentService } from '../services/agentService';
import type { ResearchRequest } from '../shared/types';
import { join } from 'path';
import { writeFile, mkdir } from 'fs/promises';

export class AgentManager {
  private projectRoot: string;
  private agent: AgentService;
  private onOutput?: (type: 'stdout' | 'stderr', data: string) => void;

  constructor(projectRoot: string) {
    this.projectRoot = projectRoot;
    this.agent = new AgentService();
  }

  setOutputHandler(handler: (type: 'stdout' | 'stderr', data: string) => void) {
    this.onOutput = handler;
  }

  private logOutput(message: string) {
    if (this.onOutput) {
      this.onOutput('stdout', message + '\n');
    }
  }

  async runResearch(request: ResearchRequest): Promise<{ path: string; usage?: { input_tokens: number; output_tokens: number } }> {
    try {
      const result = await this.agent.research(
        {
          companyName: request.companyName || request.ticker,
          ticker: request.ticker
        },
        (message) => this.logOutput(message)
      );

      // Log token usage if available
      if (result.usage) {
        const total = result.usage.input_tokens + result.usage.output_tokens;
        this.logOutput(`üìä Token usage: ${result.usage.input_tokens} in + ${result.usage.output_tokens} out = ${total} total`);
      }

      // Clean up result - remove any leading asterisks or markdown artifacts
      const cleanResult = result.response.replace(/^\*+/, '').trim();
      
      // Generate output filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const outputFile = `research-${request.ticker}-${timestamp}.md`;
      const reportsDir = join(this.projectRoot, 'reports');
      
      // Ensure reports directory exists
      await mkdir(reportsDir, { recursive: true });
      
      const fullPath = join(reportsDir, outputFile);
      
      // Prepare the full report
      const reportType = 'Research Report';
      const fullReport = [
        `# ${reportType}`,
        `**Company:** ${request.companyName || request.ticker}`,
        `**Ticker:** ${request.ticker}`,
        `**Date:** ${new Date().toLocaleString()}`,
        '',
        '---',
        '',
        cleanResult,
        '',
        '---',
        `*Generated by Family Office Research Agent*`
      ].join('\n');
      
      // Write to file
      await writeFile(fullPath, fullReport);
      
      this.logOutput(`‚úÖ ${reportType} saved to: ${outputFile}`);
      
      return {
        path: fullPath,
        usage: result.usage
      };
    } catch (error) {
      const errorMsg = `Research failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
      this.logOutput(errorMsg);
      throw new Error(errorMsg);
    }
  }

  async runReevaluate(request: ResearchRequest, existingReportPath: string): Promise<{ path: string; usage?: { input_tokens: number; output_tokens: number } }> {
    try {
      // Read the existing report
      const fs = await import('fs/promises');
      const reportContent = await fs.readFile(existingReportPath, 'utf-8');
      
      const result = await this.agent.reevaluate(
        {
          companyName: request.companyName || request.ticker,
          ticker: request.ticker,
          existingReport: reportContent
        },
        (message) => this.logOutput(message)
      );

      // Log token usage if available
      if (result.usage) {
        const total = result.usage.input_tokens + result.usage.output_tokens;
        this.logOutput(`üìä Token usage: ${result.usage.input_tokens} in + ${result.usage.output_tokens} out = ${total} total`);
      }

      // Clean up result - remove any leading asterisks or markdown artifacts
      const cleanResult = result.response.replace(/^\*+/, '').trim();
      
      // Generate output filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const outputFile = `research-${request.ticker}-${timestamp}.md`;
      const reportsDir = join(this.projectRoot, 'reports');
      
      // Ensure reports directory exists
      await mkdir(reportsDir, { recursive: true });
      
      const fullPath = join(reportsDir, outputFile);
      
      // Prepare the full report
      const fullReport = [
        '# Reevaluation Report',
        `**Company:** ${request.companyName || request.ticker}`,
        `**Ticker:** ${request.ticker}`,
        `**Date:** ${new Date().toLocaleString()}`,
        `**Original Report:** ${existingReportPath}`,
        '',
        '---',
        '',
        cleanResult,
        '',
        '---',
        `*Generated by Family Office Research Agent*`,
        `*Reevaluation of existing report*`
      ].join('\n');
      
      // Write to file
      await writeFile(fullPath, fullReport);
      
      this.logOutput(`‚úÖ Reevaluation report saved to: ${outputFile}`);
      
      return {
        path: fullPath,
        usage: result.usage
      };
    } catch (error) {
      const errorMsg = `Reevaluation failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
      this.logOutput(errorMsg);
      throw new Error(errorMsg);
    }
  }

  async runChat(ticker: string, message: string, reportPath?: string, onStream?: (text: string) => void, referenceReports?: Array<{ticker: string, content: string}>): Promise<{ response: string; usage?: { input_tokens: number; output_tokens: number } }> {
    try {
      let reportContent: string | undefined;
      
      if (reportPath) {
        try {
          const fs = await import('fs/promises');
          reportContent = await fs.readFile(reportPath, 'utf-8');
          this.logOutput(`üìÑ Loaded report: ${reportPath}`);
        } catch (error) {
          this.logOutput(`‚ùå Error loading report: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
      }

      const result = await this.agent.chat(
        ticker,
        message,
        reportContent,
        (message) => this.logOutput(message),
        onStream,
        referenceReports
      );

      return result;
    } catch (error) {
      const errorMsg = `Chat failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
      this.logOutput(errorMsg);
      throw new Error(errorMsg);
    }
  }

  async updateReport(ticker: string, chatHistory?: any[]): Promise<{ path: string; usage?: { input_tokens: number; output_tokens: number } }> {
    console.log(`\nüîÑ [AGENT_MANAGER DEBUG] Starting updateReport for ticker: ${ticker}`);
    console.log(`üìö [AGENT_MANAGER DEBUG] Chat history: ${chatHistory ? `${chatHistory.length} messages` : 'none provided'}`);
    this.logOutput(`üîÑ [AGENT_MANAGER DEBUG] Starting updateReport for ticker: ${ticker}`);
    
    try {
      console.log(`üìû [AGENT_MANAGER DEBUG] Calling agent.updateReport('${ticker}', chatHistory)`);
      const result = await this.agent.updateReport(
        ticker,
        chatHistory,
        (message) => {
          console.log(`üìä [AGENT_MANAGER DEBUG] Progress: ${message}`);
          this.logOutput(message);
        }
      );

      console.log(`üìÑ [AGENT_MANAGER DEBUG] Received result: ${result.response.length} characters`);

      // Log token usage if available
      if (result.usage) {
        const total = result.usage.input_tokens + result.usage.output_tokens;
        this.logOutput(`üìä Token usage: ${result.usage.input_tokens} in + ${result.usage.output_tokens} out = ${total} total`);
      }

      // Clean up result - remove any leading asterisks or markdown artifacts
      const cleanResult = result.response.replace(/^\*+/, '').trim();
      
      console.log(`üßπ [AGENT_MANAGER DEBUG] Cleaned result: ${cleanResult.length} characters`);
      
      // Generate output filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const outputFile = `research-${ticker}-${timestamp}.md`;
      const reportsDir = join(this.projectRoot, 'reports');
      
      console.log(`üìÅ [AGENT_MANAGER DEBUG] Target directory: ${reportsDir}`);
      console.log(`üìÑ [AGENT_MANAGER DEBUG] Output filename: ${outputFile}`);
      
      // Ensure reports directory exists
      await mkdir(reportsDir, { recursive: true });
      
      const fullPath = join(reportsDir, outputFile);
      console.log(`üìç [AGENT_MANAGER DEBUG] Full path: ${fullPath}`);
      
      // Prepare the full report
      const fullReport = [
        '# Research Report',
        `**Company:** ${ticker}`,
        `**Ticker:** ${ticker}`,
        `**Date:** ${new Date().toLocaleString()}`,
        `**Updated:** ${new Date().toLocaleString()}`,
        '',
        '---',
        '',
        cleanResult,
        '',
        '---',
        `*Generated by Family Office Research Agent*`,
        `*Updated during chat session*`
      ].join('\n');
      
      console.log(`üìù [AGENT_MANAGER DEBUG] Writing report: ${fullReport.length} characters`);
      
      // Write to file
      await writeFile(fullPath, fullReport);
      
      console.log(`‚úÖ [AGENT_MANAGER DEBUG] Successfully wrote file: ${fullPath}`);
      this.logOutput(`‚úÖ Updated report saved to: ${outputFile}`);
      
      return {
        path: fullPath,
        usage: result.usage
      };
    } catch (error) {
      const errorMsg = `Report update failed: ${error instanceof Error ? error.message : 'Unknown error'}`;
      console.error(`‚ùå [AGENT_MANAGER DEBUG] ${errorMsg}`);
      console.error(`‚ùå [AGENT_MANAGER DEBUG] Error details:`, error);
      this.logOutput(errorMsg);
      throw new Error(errorMsg);
    }
  }

  async cleanup(): Promise<void> {
    await this.agent.cleanup();
  }
}
